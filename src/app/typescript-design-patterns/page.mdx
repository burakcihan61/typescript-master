export const metadata = {
  title: "TypeScript Design Patterns",
  description:
    "TypeScript, JavaScript tabanlı bir programlama dilidir ve genellikle büyük ölçekli uygulamaların geliştirilmesi için kullanılır.",
}

# Design Patterns

TypeScript, JavaScript tabanlı bir programlama dilidir ve genellikle büyük ölçekli uygulamaların geliştirilmesi için kullanılır. TypeScript, JavaScript'in yanı sıra statik tür sistemine sahip olduğu için, kodunuzun daha güvenli ve sürdürülebilir olmasına olanak tanır. Bu nedenle, TypeScript projelerinde tasarım kalıpları, kodun düzenlenmesi, sürdürülebilirliği artırmak ve hataları azaltmak için önemli bir rol oynar.

Design pattern'lar, belirli problemleri çözmek veya belirli durumlarla başa çıkmak için geliştirilmiş genel çözüm şablonlarıdır. TypeScript tasarım kalıpları da aynı prensiplere dayanır ve genellikle aşağıdaki amaçlara hizmet eder:

<Note>
  * **Düzen ve Organizasyon**: Design pattern'lar, kodunuzun düzenli ve
  anlaşılır olmasına yardımcı olabilir. Projenizin büyüklüğü arttıkça, düzenli
  bir yapıya sahip olmak, kodunuzun bakımını kolaylaştırır.
  * **Tekrar
  Kullanım**: Design pattern'lar, belirli bir problemi çözmek için genel bir
  çözüm sağladığından, bu çözümleri başka yerlerde tekrar kullanabilirsiniz. Bu,
  kodunuzun daha az tekrar içermesine ve daha az hata içermesine yardımcı
  olabilir.
  * **Hata Azaltma**: Design pattern'lar, belirli bir problemin çözümü
  için test edilmiş ve doğrulanmış bir yaklaşım sunar. Bu nedenle, bu kalıpları
  kullanmak, hataları azaltmanıza yardımcı olabilir.
  * **Değişikliklere Direnç**: Tasarım kalıpları, değişikliklere karşı dirençli olacak şekilde
  tasarlanabilir. Yani, projenizde yapılan değişikliklerin diğer kısımları
  etkileme olasılığını azaltabilir.
  * **Performans**: Design pattern'lar,
  belirli bir problemin çözümü için optimize edilmiş bir yaklaşım sunar. Bu
  nedenle, bu kalıpları kullanmak, performansı artırmanıza yardımcı olabilir.
  *  **Ölçeklenebilirlik**: Design pattern'lar, belirli bir problemin çözümü için
  optimize edilmiş bir yaklaşım sunar. Bu nedenle, bu kalıpları kullanmak,
  performansı artırmanıza yardımcı olabilir.
  * **Esneklik**: Design pattern'lar,
  belirli bir problemin çözümü için optimize edilmiş bir yaklaşım sunar. Bu
  nedenle, bu kalıpları kullanmak, performansı artırmanıza yardımcı olabilir.
</Note>

## Singletons Deseni

Singleton deseni, bir sınıfın yalnızca bir örneğinin olduğundan emin olmayı amaçlayan bir tasarım desenidir. TypeScript dilinde de Singleton deseni kullanılabilir, ancak TypeScript'in doğası gereği, bazı dillerdeki gibi tam anlamıyla private constructor (özel kurucu) kullanmak mümkün değildir. Bununla birlikte, Singleton desenini uygulamak için bazı yöntemler vardır.

İlk olarak, bir sınıfın yalnızca bir örneğini tutmak için bir statik özellik kullanabilirsiniz. Aşağıda, TypeScript ile basit bir Singleton örneği gösterilmektedir:

<CodeGroup title="Singleton">

```ts
class Singleton {
  private static instance: Singleton | null = null

  private constructor() {
    // private constructor
  }

  public static getInstance(): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton()
    }

    return Singleton.instance
  }

  public doSomething(): void {
    console.log("Singleton is doing something")
  }
}

// Kullanım örneği
const singleton1 = Singleton.getInstance()
const singleton2 = Singleton.getInstance()

console.log(singleton1 === singleton2) // true
```

</CodeGroup>

<div>
  Bu örnekte, `getInstance` metodu ile Singleton sınıfının tek bir örneğini alabilirsiniz. Eğer daha önce bir örnek oluşturulmamışsa, `getInstance` metodu yeni bir örnek oluşturur ve bu örneği döndürür. Eğer önce bir örnek oluşturulmuşsa, mevcut örneği döndürür.

Ancak, bu yöntem tam anlamıyla private constructor kullanmaz ve `new Singleton()` ifadesi herhangi bir yerde çağrılabilir. Bu nedenle, sınıfın oluşturulmasını sınırlamak için belirli bir yöntem kullanılması önemlidir.

Bu örnekte, TypeScript'in private constructor özelliği olmadığı için `private constructor()` kullanılarak sınıfın dışından doğrudan bir örneği oluşturulması engellenir. Ancak, dikkatli olunması ve Singleton desenini doğru bir şekilde uygulamak için belirli durumları düşünmek önemlidir.

</div>

## Factory Deseni

Factory deseni (Factory Pattern), bir nesne yaratma sürecini kapsülleme amacı güden bir creational (yaratıcı) tasarım desenidir. Bu desen, nesne oluşturma mantığını ana sınıftan ayırarak, bir alt sınıfın hangi sınıfın nesnesini oluşturacağını belirlemesine izin verir.

Factory deseni, genellikle bir arayüz veya soyut bir sınıf üzerinde duran bir "fabrika" sınıfını içerir. Alt sınıflar bu arayüzü veya soyut sınıfı uygular ve kendi özelleştirilmiş nesnelerini oluşturmak için gerekli yöntemleri sağlarlar.

İşte TypeScript ile basit bir Factory deseni örneği:

<CodeGroup title="Factory">

```ts
// Ürün arayüzü veya soyut sınıf
interface Product {
  operation(): string
}

// ConcreteProduct1
class ConcreteProduct1 implements Product {
  operation(): string {
    return "ConcreteProduct1 operation"
  }
}

// ConcreteProduct2
class ConcreteProduct2 implements Product {
  operation(): string {
    return "ConcreteProduct2 operation"
  }
}

// Fabrika arayüzü veya soyut sınıf
interface Creator {
  factoryMethod(): Product
}

// ConcreteCreator1
class ConcreteCreator1 implements Creator {
  factoryMethod(): Product {
    return new ConcreteProduct1()
  }
}

// ConcreteCreator2
class ConcreteCreator2 implements Creator {
  factoryMethod(): Product {
    return new ConcreteProduct2()
  }
}

// Kullanım
function clientCode(creator: Creator): void {
  const product = creator.factoryMethod()
  console.log(product.operation())
}

// Kullanım örneği
const creator1 = new ConcreteCreator1()
clientCode(creator1)

const creator2 = new ConcreteCreator2()
clientCode(creator2)
```

</CodeGroup>

<div>
  Bu örnekte, `Product` arayüzü veya soyut sınıf, oluşturulacak nesnelerin ortak davranışlarını tanımlar. `ConcreteProduct1` ve `ConcreteProduct2` sınıfları bu arayüzü uygular ve kendi özel davranışlarını sağlarlar.

`Creator` arayüzü veya soyut sınıf, fabrika metodunu tanımlar. Bu metod, alt sınıfların hangi ürünü oluşturacaklarını belirler. `ConcreteCreator1` ve `ConcreteCreator2` sınıfları, bu arayüzü uygular ve kendi factoryMethod implementasyonlarını sağlarlar.

Son olarak, `clientCode` fonksiyonu, bir `Creator` örneği alır ve bu creatörün `factoryMethod`'unu çağırarak belirli bir ürünü oluşturur ve kullanır. Bu şekilde, istemci kodu hangi ürünü kullanacağını bilmeksizin bir nesne yaratabilir.

</div>

## Observer Deseni

Observer deseni, bir nesnenin durumundaki değişiklikleri takip etmek isteyen bir dizi nesnenin (gözlemcilerin) bir nesneye abone olmasını sağlayan bir tasarım desenidir. Bu desen, bir nesnenin durumunda değişiklik olduğunda bağımlı nesneleri otomatik olarak güncellemek için kullanılır. Bu durum, bir nesnenin durumu değiştikçe diğer nesnelerin tepki vermesini sağlar.

Bu desenin ana bileşenleri şunlardır:

- **Subject (Konu)**: Gözlemleyicileri (observers) içeren bir nesne. Durumu değiştikçe gözlemcilerini haberdar eder.

- **Observer (Gözlemci)**: Bir konu üzerinde değişiklikleri takip etmek isteyen arayüze sahip nesneler.

Observer deseni, yaygın olarak kullanıcı arayüzleri, olay sistemleri ve veri alma/gönderme gibi birçok senaryoda kullanılır.

İşte TypeScript ile basit bir Observer deseni örneği:

<CodeGroup title="Observer">

```ts
// Subject (Konu) arayüzü veya soyut sınıf
interface Subject {
  addObserver(observer: Observer): void
  removeObserver(observer: Observer): void
  notifyObservers(): void
}

// ConcreteSubject (Somut Konu)
class ConcreteSubject implements Subject {
  private observers: Observer[] = []
  private state: number = 0

  addObserver(observer: Observer): void {
    this.observers.push(observer)
  }

  removeObserver(observer: Observer): void {
    const index = this.observers.indexOf(observer)
    if (index !== -1) {
      this.observers.splice(index, 1)
    }
  }

  notifyObservers(): void {
    for (const observer of this.observers) {
      observer.update(this.state)
    }
  }

  setState(state: number): void {
    this.state = state
    this.notifyObservers()
  }
}

// Observer (Gözlemci) arayüzü veya soyut sınıf
interface Observer {
  update(state: number): void
}

// ConcreteObserver (Somut Gözlemci)
class ConcreteObserver implements Observer {
  private name: string

  constructor(name: string) {
    this.name = name
  }

  update(state: number): void {
    console.log(`${this.name} notified with state: ${state}`)
  }
}

// Kullanım
const subject = new ConcreteSubject()

const observer1 = new ConcreteObserver("Observer 1")
const observer2 = new ConcreteObserver("Observer 2")

subject.addObserver(observer1)
subject.addObserver(observer2)

subject.setState(1)
subject.setState(2)

// Çıktı:
// Observer 1 notified with state: 1
// Observer 2 notified with state: 1
// Observer 1 notified with state: 2
// Observer 2 notified with state: 2
```

</CodeGroup>

<div>
  Bu örnekte, `ConcreteSubject` bir `Subject` arayüzünü uygular ve
  `ConcreteObserver` bir `Observer` arayüzünü uygular. `ConcreteSubject`,
  içerdiği gözlemcileri (`observers`) takip eder ve durumu değiştiğinde bu
  gözlemcilere haber verir. `ConcreteObserver` ise durumu alır ve kendine özgü
  bir şekilde tepki verir.
</div>

## Decorator Deseni

Decorator deseni, nesne üzerinde dinamik olarak davranış eklemek için kullanılan bir tasarım desenidir. Bu desen, bir nesneyi sarmalayarak (wrap) ve bu sarmalayıcı nesneye ek işlevsellik ekleyerek çalışır. Bu sayede, nesne üzerinde yapılan değişiklikler, nesnenin sarmalayıcıları aracılığıyla etki eder ve bu değişiklikler çalışma zamanında gerçekleştirilebilir.

Decorator deseni, Open/Closed prensibine (bir sınıfın davranışını değiştirmek için sınıfın değiştirilmemesi) uyan ve bir nesnenin davranışını genişletmek veya değiştirmek istediğimizde tercih ettiğimiz bir desenidir.

İşte TypeScript ile basit bir Decorator deseni örneği:

<CodeGroup title="Decorator">

```ts
// Component (Bileşen) arayüzü veya soyut sınıf
interface Coffee {
  cost(): number
  description(): string
}

// ConcreteComponent (Somut Bileşen)
class SimpleCoffee implements Coffee {
  cost(): number {
    return 5
  }

  description(): string {
    return "Simple coffee"
  }
}

// Decorator (Dekoratör) arayüzü veya soyut sınıf
abstract class CoffeeDecorator implements Coffee {
  protected decoratedCoffee: Coffee

  constructor(coffee: Coffee) {
    this.decoratedCoffee = coffee
  }

  cost(): number {
    return this.decoratedCoffee.cost()
  }

  description(): string {
    return this.decoratedCoffee.description()
  }
}

// ConcreteDecorator (Somut Dekoratör)
class MilkDecorator extends CoffeeDecorator {
  constructor(coffee: Coffee) {
    super(coffee)
  }

  cost(): number {
    return this.decoratedCoffee.cost() + 2
  }

  description(): string {
    return this.decoratedCoffee.description() + ", with milk"
  }
}

// ConcreteDecorator (Somut Dekoratör)
class SugarDecorator extends CoffeeDecorator {
  constructor(coffee: Coffee) {
    super(coffee)
  }

  cost(): number {
    return this.decoratedCoffee.cost() + 1
  }

  description(): string {
    return this.decoratedCoffee.description() + ", with sugar"
  }
}

// Kullanım
const simpleCoffee: Coffee = new SimpleCoffee()
console.log(
  `Cost: $${simpleCoffee.cost()}, Description: ${simpleCoffee.description()}`
)

const milkCoffee: Coffee = new MilkDecorator(new SimpleCoffee())
console.log(
  `Cost: $${milkCoffee.cost()}, Description: ${milkCoffee.description()}`
)

const sugarMilkCoffee: Coffee = new SugarDecorator(
  new MilkDecorator(new SimpleCoffee())
)
console.log(
  `Cost: $${sugarMilkCoffee.cost()}, Description: ${sugarMilkCoffee.description()}`
)
```

</CodeGroup>

<div>
  Bu örnekte, `Coffee` arayüzü veya soyut sınıf, dekore edilecek nesnenin temel davranışını belirtir. `SimpleCoffee` sınıfı, bu arayüzü uygular ve temel kahve davranışını sağlar.

`CoffeeDecorator` soyut sınıfı, dekoratörlerin uygulanmasını sağlar ve `ConcreteDecorator` sınıfları, gerçek dekorasyonları uygular. Örneğin, `MilkDecorator` sınıfı süt eklerken, `SugarDecorator` sınıfı şeker ekler.

Sonuç olarak, `SimpleCoffee` nesnesi üzerine `MilkDecorator` ve `SugarDecorator` sarmalayıcıları ekleyerek yeni özellikler ekleyebilir ve nesnenin davranışını değiştirebilirsiniz.

</div>

## Prototype Deseni

Prototype deseni, nesnelerin kopyalarını oluşturmak için kullanılan bir tasarım desenidir. Bu desen, nesne oluşturma sürecini bir prototip nesnesinden türetilen kopyalar üzerinden gerçekleştirir. Bu sayede, bir nesnenin yeni kopyalarını oluşturmak için sınıf hiyerarşilerini yeniden oluşturmak gerekmez.

Prototype deseni, özellikle nesnenin karmaşık bir inşa sürecine sahip olduğu durumlarda kullanışlıdır. Bu desen, nesne oluşturma maliyetini düşürerek ve yeni nesnelerin başka nesnelerle aynı başlangıç durumlarına sahip olmasını sağlayarak performans ve bellek kullanımını iyileştirebilir.

İşte TypeScript ile basit bir Prototype deseni örneği:

<CodeGroup title="Prototype">

```ts
// Prototype (Prototip) arayüzü veya soyut sınıf
interface Cloneable {
  clone(): Cloneable
}

// ConcretePrototype (Somut Prototip)
class ConcretePrototype implements Cloneable {
  private property1: string
  private property2: number

  constructor(property1: string, property2: number) {
    this.property1 = property1
    this.property2 = property2
  }

  clone(): Cloneable {
    // Yeni bir kopya oluşturulur ve mevcut özellikler kopyalanır
    return new ConcretePrototype(this.property1, this.property2)
  }

  // Diğer metotlar ve özellikler...
}

// Kullanım
const prototypeInstance1 = new ConcretePrototype("Value 1", 42)
const clonedInstance1 = prototypeInstance1.clone()

console.log(prototypeInstance1) // Orjinal nesne
console.log(clonedInstance1) // Kopya nesne
```

</CodeGroup>

<div>
  Bu örnekte, `Cloneable` arayüzü veya soyut sınıf, klonlama yeteneğini belirtir. `ConcretePrototype` sınıfı, bu arayüzü uygular ve klonlanabilir nesnenin yapısını ve davranışını tanımlar.

Kullanım örneğinde, `prototypeInstance1` adlı bir orijinal nesne oluşturulur. Ardından, bu nesnenin clone metodunu kullanarak bir kopyası olan `clonedInstance1` oluşturulur. Bu sayede, `clonedInstance1` ve `prototypeInstance1` nesneleri aynı başlangıç durumlarına sahip olur, ancak bağımsız nesnelerdir.

Prototype deseni, özellikle nesnenin içeriği karmaşık ve nesnenin kopyalanması maliyetli olduğu durumlarda kullanılır.

</div>

## Builder Deseni


Builder deseni, bir nesnenin karmaşık yapısını adım adım oluşturan ve nesnenin farklı temsil biçimlerini üretebilen bir tasarım desenidir. Builder deseni, bir nesnenin inşa edilmesi sürecini ayrı bir sınıfa taşıyarak, nesnenin farklı özelliklerini kontrol etmeyi ve bu özelliklere göre nesneyi oluşturmayı sağlar.

İşte TypeScript ile Builder desenini uygulamak için basit bir örnek:

<CodeGroup title="Builder">

  ```ts
  // Üretilen nesne için temsil edilecek arayüz
  class Product {
  private parts: string[] = [];

  addPart(part: string): void {
  this.parts.push(part);
}

  showParts(): void {
  console.log(`Product Parts: ${this.parts.join(', ')}`);
}
}

  // Builder arayüzü
  interface Builder {
  buildPartA(): void;
  buildPartB(): void;
  getResult(): Product;
}

  // ConcreteBuilder sınıfı: Builder arayüzünü uygular
  class ConcreteBuilder implements Builder {
  private product: Product = new Product();

  buildPartA(): void {
  this.product.addPart('PartA');
}

  buildPartB(): void {
  this.product.addPart('PartB');
}

  getResult(): Product {
  return this.product;
}
}

  // Director sınıfı: Builder'ı kullanarak nesne inşa eder
  class Director {
  private builder: Builder;

  constructor(builder: Builder) {
  this.builder = builder;
}

  construct(): void {
  this.builder.buildPartA();
  this.builder.buildPartB();
}
}

  // Kullanım
  const builder: Builder = new ConcreteBuilder();
  const director: Director = new Director(builder);

  director.construct();

  const product: Product = builder.getResult();
  product.showParts();

  ```

</CodeGroup>

<div>
  Bu örnekte, `Product` sınıfı, oluşturulacak nesneyi temsil eder. `Builder` arayüzü, nesnenin inşa edilme sürecini tanımlar. `ConcreteBuilder` sınıfı, `Builder` arayüzünü uygular ve nesnenin farklı parçalarını ekler. `Director` sınıfı, `Builder`'ı kullanarak nesneyi inşa eder.

  Bu sayede, `Director` sınıfı, nesnenin hangi parçalardan oluşacağını belirler, ancak hangi parçaların eklenip çıkarılacağı `ConcreteBuilder` sınıfında belirlenir. Bu, nesne oluşturma sürecini daha esnek hale getirir ve farklı varyasyonlarda nesneler oluşturmak için kullanışlıdır.

</div>

## Facade Deseni



Facade deseni, bir alt sistemdeki nesnelerin karmaşıklığını gizleyen ve bir arayüz sağlayan bir tasarım desenidir. Bu desen, bir alt sistemin iç yapısını müşterilere karşı gizleyerek, alt sistemin kullanımını daha basitleştirir ve daha yüksek seviyeli bir arabirim sunar.

İşte TypeScript ile basit bir Facade deseni örneği:

<CodeGroup title="Facade">

  ```ts
  // Alt sistem sınıfları
  class SubsystemA {
  operationA(): string {
  return 'Subsystem A operation';
}
}

  class SubsystemB {
  operationB(): string {
  return 'Subsystem B operation';
}
}

  class SubsystemC {
  operationC(): string {
  return 'Subsystem C operation';
}
}

  // Facade sınıfı
  class Facade {
  private subsystemA: SubsystemA;
  private subsystemB: SubsystemB;
  private subsystemC: SubsystemC;

  constructor() {
  this.subsystemA = new SubsystemA();
  this.subsystemB = new SubsystemB();
  this.subsystemC = new SubsystemC();
}

  operation(): string {
  let result = 'Facade initiates operations:\n';
  result += this.subsystemA.operationA() + '\n';
  result += this.subsystemB.operationB() + '\n';
  result += this.subsystemC.operationC();
  return result;
}
}

  // Kullanım
  const facade = new Facade();
  const result = facade.operation();
  console.log(result);

  ```

</CodeGroup>

<div>

  Bu örnekte, `SubsystemA`, `SubsystemB`, ve `SubsystemC` alt sistem sınıflarını temsil eder. Bu sınıflar, karmaşık işlemleri gerçekleştirir. `Facade` sınıfı ise bu alt sistemleri yöneten ve müşterilere basitleştirilmiş bir arabirim sunan sınıftır.

  Facade deseni, alt sistemlerin iç yapısındaki karmaşıklığı gizleyerek, müşterinin daha basit bir şekilde kullanımını sağlar. Bu, alt sistemlerdeki değişikliklerin müşteri kodunu etkilememesini sağlar. Facade, alt sistemlerin bir arada çalışmasını koordine edebilir ve müşteriye tek bir noktadan erişim sağlar.

  Bu desen, bir uygulamanın çeşitli bileşenlerini birleştiren ve müşteri kodu için basit bir arayüz sunan durumlarda özellikle faydalıdır.
</div>

## Proxy Deseni



Proxy deseni, bir nesnenin yerine geçen bir kontrol noktasıdır ve bu sayede gerçek nesneyle olan etkileşimi kontrol eder. Bu desen, performans optimizasyonu, erişim kontrolü, giriş doğrulaması veya bir nesnenin yaratılma maliyetinden kaçınma gibi senaryolarda kullanılır.

İşte TypeScript ile basit bir Proxy deseni örneği:

<CodeGroup title="Proxy">

  ```ts
  // Temel öznenin arayüzü
  interface Subject {
  request(): void;
}

  // Gerçek özne sınıfı
  class RealSubject implements Subject {
  request(): void {
  console.log('RealSubject: Handling request.');
}
}

  // Proxy sınıfı
  class Proxy implements Subject {
  private realSubject: RealSubject;

  constructor(realSubject: RealSubject) {
  this.realSubject = realSubject;
}

  private checkAccess(): boolean {
  console.log('Proxy: Checking access.');
  // Burada gerçek bir erişim kontrolü gerçekleştirilebilir.
  return true;
}

  private logAccess(): void {
  console.log('Proxy: Logging access.');
}

  request(): void {
  if (this.checkAccess()) {
  this.realSubject.request();
  this.logAccess();
}
}
}

  // Kullanım
  const realSubject = new RealSubject();
  const proxy = new Proxy(realSubject);

  // Gerçek özneye doğrudan erişim
  realSubject.request();

  // Proxy üzerinden erişim
  proxy.request();


  ```

</CodeGroup>

<div>
  Bu örnekte, `Subject` arayüzü, gerçek öznenin ve proxy'nin uyguladığı arayüzdür. `RealSubject` sınıfı, gerçek işlemleri gerçekleştiren sınıftır. `Proxy` sınıfı ise erişim kontrolü ve loglama gibi ek işlevsellik ekler.

  Proxy deseni, gerçek nesnenin yaratılması veya kullanılması için ek bir kontrol ekler, böylece gerçek nesnenin yaratılma maliyetinden veya gereksiz işlemlerden kaçınılabilir. Aynı zamanda, erişim kontrolü gibi işlevselliği gerçekleştirebilir ve gerçek nesnenin davranışını kontrol edebilir. Bu sayede, istemci kodu değiştirmeden önce veya sonra ek işlevselliği uygulamak daha kolay olabilir.
</div>

## Iterator Deseni


Iterator deseni, bir nesne koleksiyonu üzerinde sırayla gezinmek için bir arayüz sağlayan ve bu koleksiyonun altında bulunan elemanlara erişimi standartlaştıran bir tasarım desenidir. Iterator deseni, koleksiyonun iç yapısını gizler ve istemcilerin koleksiyon üzerinde gezinmeyi basitleştirir.

İşte TypeScript ile basit bir Iterator deseni örneği:

<CodeGroup title="Iterator ">

  ```ts
  // Iterator arayüzü
  interface Iterator<T> {
  next(): T;
  hasNext(): boolean;
}

  // Aggregate arayüzü
  interface Aggregate<T> {
    createIterator(): Iterator<T>;
  }

    // ConcreteAggregate sınıfı
    class ConcreteAggregate<T> implements Aggregate<T> {
      private items: T[] = [];

      addItem(item: T): void {
      this.items.push(item);
    }

      createIterator(): Iterator<T> {
      return new ConcreteIterator<T>(this);
    }

      getItems(): T[] {
      return this.items;
    }
    }

      // ConcreteIterator sınıfı
      class ConcreteIterator<T> implements Iterator<T> {
        private aggregate: ConcreteAggregate<T>;
        private index: number = 0;

        constructor(aggregate: ConcreteAggregate<T>) {
        this.aggregate = aggregate;
      }

        next(): T {
        const currentItem = this.aggregate.getItems()[this.index];
        this.index++;
        return currentItem;
      }

        hasNext(): boolean {
        return this.index < this.aggregate.getItems().length;
      }
      }

        // Kullanım
        const aggregate = new ConcreteAggregate<number>();
          aggregate.addItem(1);
          aggregate.addItem(2);
          aggregate.addItem(3);

          const iterator = aggregate.createIterator();

          while (iterator.hasNext()) {
            const currentItem = iterator.next();
            console.log(`Item: ${currentItem}`);
          }

          ```

</CodeGroup>

<div>
  Bu örnekte, `Iterator` arayüzü, koleksiyon üzerinde gezinme işlemlerini tanımlar. `Aggregate` arayüzü ise bu koleksiyonları oluşturacak sınıflar için bir arayüz sağlar. `ConcreteAggregate` sınıfı, koleksiyonu temsil eder ve `ConcreteIterator` sınıfı, bu koleksiyon üzerinde gezinme işlemlerini uygular.

  Iterator deseni, koleksiyonun iç yapısını gizler ve istemcilerin koleksiyon üzerinde dolaşmasını standartlaştırır. Bu sayede, koleksiyonun iç yapısı değişse bile istemci kodunu değiştirmeye gerek kalmaz. Aynı zamanda, koleksiyon üzerinde farklı gezinme algoritmaları uygulanabilir ve istemci kodu değiştirmeden bu algoritmalar kullanılabilir.
</div>

## Adapter Deseni

Adapter deseni, bir sınıfın arabirimini, başka bir sınıfın beklediği arabirime dönüştüren bir yapısal tasarım desenidir. Bu desen, uyumsuz arabirimlere sahip sınıfların birbirleriyle etkileşimini sağlar.

İşte TypeScript ile basit bir Adapter deseni örneği:

<CodeGroup title="Adapter">

  ```ts
  // Hedef Arabirim
  interface Target {
  request(): string;
}

  // Hedefe Uygun Sınıf
  class ConcreteTarget implements Target {
  request(): string {
  return 'ConcreteTarget: The default behavior.';
}
}

  // Kaynak Sınıf
  class Adaptee {
  specificRequest(): string {
  return 'Adaptee: The specific behavior.';
}
}

  // Adaptör Sınıfı
  class Adapter implements Target {
  private adaptee: Adaptee;

  constructor(adaptee: Adaptee) {
  this.adaptee = adaptee;
}

  request(): string {
  return `Adapter: (Translated) ${this.adaptee.specificRequest()}`;
}
}

  // Kullanım
  const target: Target = new ConcreteTarget();
  console.log(target.request());

  const adaptee: Adaptee = new Adaptee();
  const adapter: Target = new Adapter(adaptee);
  console.log(adapter.request());

  ```

</CodeGroup>

<div>
  Bu örnekte, `Target` arabirimi, istemcinin beklediği standart arabirimi temsil eder. `ConcreteTarget` sınıfı, bu arabirimi uygular. `Adaptee` sınıfı, mevcut ancak istemcinin beklediği arabirime sahip olmayan bir sınıfı temsil eder. `Adapter` sınıfı, `Adaptee` sınıfını kullanarak `Target` arabirimini uygular. Bu sayede, `Adapter` sınıfı, `Adaptee` sınıfının özelliklerini `Target` arabirimine uyacak şekilde dönüştürür.

  Adapter deseni, mevcut sınıfların uyumlu bir şekilde birlikte çalışmasını sağlar ve mevcut kodun yeniden kullanılmasını kolaylaştırır. Adapter, uyumsuz sınıflar arasında bir ara birimi sağlayarak sistemdeki esnekliği artırır.
</div>

## Bridge Deseni

Bridge deseni, bir sınıfın uygulama ve soyutlama detaylarını ayıran ve bu iki hiyerarşiyi birbirinden bağımsız hale getiren bir yapısal tasarım desenidir. Bu desen, genişletilebilir ve değiştirilebilir bir tasarım oluşturmayı amaçlar.

İşte TypeScript ile basit bir Bridge deseni örneği:

<CodeGroup title="Bridge">

  ```ts
  // Soyut İmplementasyon
  interface Implementor {
  operationImpl(): string;
}

  // Somut İmplementasyon 1
  class ConcreteImplementorA implements Implementor {
  operationImpl(): string {
  return 'ConcreteImplementorA: Operation implementation.';
}
}

  // Somut İmplementasyon 2
  class ConcreteImplementorB implements Implementor {
  operationImpl(): string {
  return 'ConcreteImplementorB: Operation implementation.';
}
}

  // Soyut Abstraksiyon
  abstract class Abstraction {
  protected implementor: Implementor;

  constructor(implementor: Implementor) {
  this.implementor = implementor;
}

  abstract operation(): string;
}

  // Somut Abstraksiyon 1
  class RefinedAbstractionA extends Abstraction {
  operation(): string {
  return `RefinedAbstractionA: ${this.implementor.operationImpl()}`;
}
}

  // Somut Abstraksiyon 2
  class RefinedAbstractionB extends Abstraction {
  operation(): string {
  return `RefinedAbstractionB: ${this.implementor.operationImpl()}`;
}
}

  // Kullanım
  const implementorA: Implementor = new ConcreteImplementorA();
  const abstractionA: Abstraction = new RefinedAbstractionA(implementorA);
  console.log(abstractionA.operation());

  const implementorB: Implementor = new ConcreteImplementorB();
  const abstractionB: Abstraction = new RefinedAbstractionB(implementorB);
  console.log(abstractionB.operation());

  ```

</CodeGroup>

<div>
  Bu örnekte, Bridge deseni iki ayrı hiyerarşi olan soyut implementasyon (`Implementor`) ve soyut abstraksiyon (`Abstraction`) içerir. `ConcreteImplementorA` ve `ConcreteImplementorB` sınıfları, `Implementor` arayüzünü uygular ve farklı implementasyonları temsil eder. `RefinedAbstractionA` ve `RefinedAbstractionB` sınıfları, soyut abstraksiyonu uygular ve bu abstraksiyonu genişletir.

  Bridge deseni, soyut abstraksiyon ve soyut implementasyon arasındaki bağlantıyı kopararak her iki hiyerarşiyi de ayrı ayrı genişletebilir ve değiştirebilir bir yapı sağlar. Bu sayede, kodun daha esnek, genişletilebilir ve bakımı daha kolay hale gelir.
</div>

## Composite Deseni

Bridge deseni, bir sınıfın uygulama ve soyutlama detaylarını ayıran ve bu iki hiyerarşiyi birbirinden bağımsız hale getiren bir yapısal tasarım desenidir. Bu desen, genişletilebilir ve değiştirilebilir bir tasarım oluşturmayı amaçlar.

İşte TypeScript ile basit bir Bridge deseni örneği:

<CodeGroup title="Composite">

  ```ts
  // Component arayüzü
  interface Component {
  operation(): string;
}

  // Leaf sınıfı: Tek bir nesneyi temsil eder
  class Leaf implements Component {
  private name: string;

  constructor(name: string) {
  this.name = name;
}

  operation(): string {
  return `Leaf(${this.name}): Operation`;
}
}

  // Composite sınıfı: Grup nesnesini temsil eder
  class Composite implements Component {
  private children: Component[] = [];

  add(component: Component): void {
  this.children.push(component);
}

  remove(component: Component): void {
  this.children = this.children.filter((c) => c !== component);
}

  operation(): string {
  const results: string[] = [];
  for (const child of this.children) {
  results.push(child.operation());
}
  return `Composite: [${results.join(', ')}]`;
}
}

  // Kullanım
  const leaf1 = new Leaf('Leaf1');
  const leaf2 = new Leaf('Leaf2');
  const leaf3 = new Leaf('Leaf3');

  const composite = new Composite();
  composite.add(leaf1);
  composite.add(leaf2);

  const composite2 = new Composite();
  composite2.add(leaf3);
  composite2.add(composite);

  console.log(composite2.operation());

  ```

</CodeGroup>

<div>
  Bu örnekte, `Component` arayüzü, hem yaprak nesneleri (Leaf) hem de grup nesneleri (Composite) için bir arayüz sağlar. `Leaf` sınıfı, tek bir nesneyi temsil eder. `Composite` sınıfı ise grup nesnesini temsil eder ve içinde birden çok `Component` saklar.

  Composite deseni, tek bir nesne ile grup nesnelerini kullanma yeteneği sağlar. Bu sayede, müşteri kodu tek bir nesne veya grup nesneleriyle aynı şekilde etkileşimde bulunabilir. Composite deseni, hiyerarşik nesneleri bir arada kullanmak istediğiniz durumlarda kullanışlıdır.
</div>

## Flyweight Deseni

Flyweight deseni, bir nesnenin paylaşılabilir (tekrar kullanılabilir) özelliklerini ve durumunu ayrıştıran bir yapısal tasarım desenidir. Bu desen, büyük miktarlarda benzer nesneler oluşturulduğunda ve bu nesnelerin birçoğunun aynı verilere sahip olduğunda kullanılır. Böylece, bellek kullanımını azaltarak performansı artırmayı amaçlar.

İşte TypeScript ile basit bir Flyweight deseni örneği:

<CodeGroup title="Flyweight">

  ```ts
  // Flyweight arayüzü
  interface Flyweight {
  operation(extrinsicState: string): string;
}

  // ConcreteFlyweight sınıfı: Paylaşılan nesne
  class ConcreteFlyweight implements Flyweight {
  private intrinsicState: string;

  constructor(intrinsicState: string) {
  this.intrinsicState = intrinsicState;
}

  operation(extrinsicState: string): string {
  return `ConcreteFlyweight: Intrinsic(${this.intrinsicState}), Extrinsic(${extrinsicState})`;
}
}

  // Flyweight Factory sınıfı: Paylaşılan nesneleri yönetir
  class FlyweightFactory {
  private flyweights: { [key: string]: Flyweight } = {};

  getFlyweight(key: string): Flyweight {
  if (!this.flyweights[key]) {
  this.flyweights[key] = new ConcreteFlyweight(key);
}
  return this.flyweights[key];
}

  getFlyweightCount(): number {
  return Object.keys(this.flyweights).length;
}
}

  // Kullanım
  const factory = new FlyweightFactory();

  const flyweight1 = factory.getFlyweight('A');
  console.log(flyweight1.operation('X'));

  const flyweight2 = factory.getFlyweight('B');
  console.log(flyweight2.operation('Y'));

  const flyweight3 = factory.getFlyweight('A');
  console.log(flyweight3.operation('Z'));

  console.log(`Number of flyweights created: ${factory.getFlyweightCount()}`);

  ```

</CodeGroup>

<div>
  Bu örnekte, `Flyweight` arayüzü paylaşılabilir nesnelerin işlevselliğini tanımlar. `ConcreteFlyweight` sınıfı, bu arayüzü uygular ve paylaşılan nesnenin özelliklerini temsil eder. `FlyweightFactory` sınıfı, paylaşılan nesneleri yönetir ve bu nesneleri oluşturur. Kullanıcılar bu fabrikadan paylaşılan nesneleri alabilir.

  Flyweight deseni, benzer nesnelerin paylaşılabilir özelliklerini bir araya getirerek bellek kullanımını azaltır. Bu özellikle büyük veri setleri veya benzer nesnelerin çok sayıda oluşturulduğu senaryolarda performans artışı sağlar.
</div>

## Command Deseni

Command deseni, bir nesnenin bir isteği (komutu) içerdiği bir nesne oluşturarak ve bu isteği bir nesne tarafından çağrılmaya elverişli bir şekilde sarmalayarak, komutları parametreleştirme, sıralama ve sıralı bir şekilde istemci nesne tarafından geri alma gibi işlemleri sağlayan bir davranışsal tasarım desenidir.

İşte TypeScript ile basit bir Command deseni örneği:

<CodeGroup title="Command">

  ```ts
  // Command arayüzü
  interface Command {
  execute(): void;
}

  // Receiver sınıfı: Gerçek işlemleri gerçekleştiren nesne
  class Receiver {
  performAction(): void {
  console.log('Receiver: Performing action');
}
}

  // ConcreteCommand sınıfı: Command arayüzünü uygular ve Receiver'ı çağırır
  class ConcreteCommand implements Command {
  private receiver: Receiver;

  constructor(receiver: Receiver) {
  this.receiver = receiver;
}

  execute(): void {
  console.log('ConcreteCommand: Execute');
  this.receiver.performAction();
}
}

  // Invoker sınıfı: Command nesnelerini çağıran nesne
  class Invoker {
  private command: Command;

  setCommand(command: Command): void {
  this.command = command;
}

  executeCommand(): void {
  console.log('Invoker: Execute Command');
  this.command.execute();
}
}

  // Kullanım
  const receiver = new Receiver();
  const command = new ConcreteCommand(receiver);
  const invoker = new Invoker();

  invoker.setCommand(command);
  invoker.executeCommand();

  ```

</CodeGroup>

<div>
  Bu örnekte, `Command` arayüzü, komutları temsil eder. `ConcreteCommand` sınıfı, bu arayüzü uygular ve bir `Receiver` nesnesini çağırarak gerçek işlemleri gerçekleştirir. `Invoker` sınıfı, `Command` nesnelerini çağırır ve bu sayede istemci tarafından işlemi başlatır.

  Command deseni, istemci tarafından bir komutun tanımlanması, sıralanması ve gerçekleştirilmesi için esnek bir yol sağlar. Ayrıca, geri alma (undo) ve yeniden yapma (redo) gibi işlemleri yönetmek için de kullanılabilir.
</div>


## Chain of Responsibility Deseni

"Chain of Responsibility" (Sorumluluk Zinciri) tasarım deseni, bir dizi nesnenin sorumluluklarını zincirleme bir şekilde taşıdığı ve bir isteğin bu zincir üzerinde sırayla işlendiği bir yapısal tasarım desenidir. Bu desen, bir isteği işleyebilecek olan nesnenin belirlenmesini ve bu isteğin işlenene kadar zincir üzerinde ilerlemesini sağlar.

Bu desenin temel amacı, isteği işleyecek nesnenin belirlenmesini sadeleştirmek ve isteği işleyen nesnelerin birbirinden bağımsız olmasını sağlamaktır. Her bir nesne, isteği işleyebiliyorsa işler, işleyemiyorsa isteği bir sonraki nesneye iletir.

İşte TypeScript ile basit bir Chain of Responsibility deseni örneği:

<CodeGroup title="Chain of Responsibility">

  ```ts
  // Handler arayüzü
  interface Handler {
  setNext(handler: Handler): Handler;
  handleRequest(request: string): string | null;
}

  // BaseHandler sınıfı
  abstract class BaseHandler implements Handler {
  private nextHandler: Handler | null = null;

  setNext(handler: Handler): Handler {
  this.nextHandler = handler;
  return handler;
}

  handleRequest(request: string): string | null {
  if (this.nextHandler) {
  return this.nextHandler.handleRequest(request);
}
  return null;
}
}

  // ConcreteHandler sınıfları
  class ConcreteHandlerA extends BaseHandler {
  handleRequest(request: string): string | null {
  if (request === 'A') {
  return 'ConcreteHandlerA: Handling request A.';
}
  return super.handleRequest(request);
}
}

  class ConcreteHandlerB extends BaseHandler {
  handleRequest(request: string): string | null {
  if (request === 'B') {
  return 'ConcreteHandlerB: Handling request B.';
}
  return super.handleRequest(request);
}
}

  // Kullanım
  const handlerA = new ConcreteHandlerA();
  const handlerB = new ConcreteHandlerB();

  handlerA.setNext(handlerB);

  console.log(handlerA.handleRequest('A')); // ConcreteHandlerA: Handling request A.
  console.log(handlerA.handleRequest('B')); // ConcreteHandlerB: Handling request B.
  console.log(handlerA.handleRequest('C')); // null

  ```

</CodeGroup>

<div>
  Bu örnekte, `Handler` arayüzü, isteği işleyen nesnelerin ortak metotlarını tanımlar. `BaseHandler` sınıfı, bu arayüzü uygular ve bir sonraki işleyiciyi belirleme ve isteği zincir üzerinde iletimi sağlar. `ConcreteHandlerA` ve `ConcreteHandlerB` sınıfları, isteği belirli koşullara göre işleyen somut işleyici sınıflarıdır.

  Chain of Responsibility deseni, bir isteğin işlenmesi için birden fazla nesnenin sorumluluk almasına olanak tanır ve isteğin işlenme sırası belirli bir sırayla takip edilir. Bu sayede, isteği işleyecek olan nesne belirlenmiş olur ve bir nesne, isteği işleyemediyse bu istek bir sonraki nesneye iletilir.
</div>

## Interpreter Deseni


"Interpreter" (Yorumlayıcı) tasarım deseni, belirli bir dilin veya problem alanının ifadelerini yorumlamak ve işlemek için kullanılan bir yapısal tasarım desenidir. Bu desen, belirli bir dil veya ifade setini temsil etmek için bir dil ağacı oluşturur ve bu ağacı yorumlayarak belirli işlemleri gerçekleştirir.

Bu desen genellikle dil işleme veya belirli bir dildeki ifadeleri yorumlama durumlarında kullanılır. Bir dildeki ifadelerin anlamını yorumlamak için bir dil ağacı oluşturulur ve bu ağaç üzerinde dolaşarak ifadeleri yorumlamak işlemi gerçekleştirilir.

İşte basit bir aritmetik ifade yorumlayıcısı örneği:

<CodeGroup title="Interpreter">

  ```ts
  // AbstractExpression sınıfı
  interface AbstractExpression {
  interpret(): number;
}

  // TerminalExpression sınıfı
  class TerminalExpression implements AbstractExpression {
  private value: number;

  constructor(value: number) {
  this.value = value;
}

  interpret(): number {
  return this.value;
}
}

  // NonTerminalExpression sınıfı
  class AddExpression implements AbstractExpression {
  private leftExpression: AbstractExpression;
  private rightExpression: AbstractExpression;

  constructor(leftExpression: AbstractExpression, rightExpression: AbstractExpression) {
  this.leftExpression = leftExpression;
  this.rightExpression = rightExpression;
}

  interpret(): number {
  return this.leftExpression.interpret() + this.rightExpression.interpret();
}
}

  // Context sınıfı
  class Context {
  private expression: AbstractExpression;

  constructor(expression: AbstractExpression) {
  this.expression = expression;
}

  setExpression(expression: AbstractExpression): void {
  this.expression = expression;
}

  interpret(): number {
  return this.expression.interpret();
}
}

  // Kullanım
  const expression = new AddExpression(
  new TerminalExpression(5),
  new AddExpression(new TerminalExpression(3), new TerminalExpression(2))
  );

  const context = new Context(expression);
  console.log(context.interpret()); // 10

  ```

</CodeGroup>

<div>
  Bu örnekte, `AbstractExpression` arayüzü, yorumlayıcı ifadelerin ortak metotlarını tanımlar. `TerminalExpression` sınıfı, bir sayıyı temsil eden ifadeleri yorumlar. `AddExpression` sınıfı, iki ifadeyi toplar. `Context` sınıfı, bir ifadeyi yorumlamak için kullanılır.

  Interpreter deseni, bir dilin veya ifade setinin yorumlanması gereken durumlarda kullanılır. Bu desen, ifadeleri oluşturmak ve yorumlamak için bir yol sağlar, bu da genellikle dil işleme veya belirli bir dildeki kurallara dayalı işlemler için uygundur.
</div>
