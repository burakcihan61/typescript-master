export const metadata = {
  title: "TypeScript Design Patterns",
  description:
    "TypeScript, JavaScript tabanlı bir programlama dilidir ve genellikle büyük ölçekli uygulamaların geliştirilmesi için kullanılır.",
}

# Design Patterns

TypeScript, JavaScript tabanlı bir programlama dilidir ve genellikle büyük ölçekli uygulamaların geliştirilmesi için kullanılır. TypeScript, JavaScript'in yanı sıra statik tür sistemine sahip olduğu için, kodunuzun daha güvenli ve sürdürülebilir olmasına olanak tanır. Bu nedenle, TypeScript projelerinde tasarım kalıpları, kodun düzenlenmesi, sürdürülebilirliği artırmak ve hataları azaltmak için önemli bir rol oynar.

Design pattern'lar, belirli problemleri çözmek veya belirli durumlarla başa çıkmak için geliştirilmiş genel çözüm şablonlarıdır. TypeScript tasarım kalıpları da aynı prensiplere dayanır ve genellikle aşağıdaki amaçlara hizmet eder:

<Note>
  * **Düzen ve Organizasyon**: Design pattern'lar, kodunuzun düzenli ve
  anlaşılır olmasına yardımcı olabilir. Projenizin büyüklüğü arttıkça, düzenli
  bir yapıya sahip olmak, kodunuzun bakımını kolaylaştırır.
  * **Tekrar
  Kullanım**: Design pattern'lar, belirli bir problemi çözmek için genel bir
  çözüm sağladığından, bu çözümleri başka yerlerde tekrar kullanabilirsiniz. Bu,
  kodunuzun daha az tekrar içermesine ve daha az hata içermesine yardımcı
  olabilir.
  * **Hata Azaltma**: Design pattern'lar, belirli bir problemin çözümü
  için test edilmiş ve doğrulanmış bir yaklaşım sunar. Bu nedenle, bu kalıpları
  kullanmak, hataları azaltmanıza yardımcı olabilir.
  * **Değişikliklere Direnç**: Tasarım kalıpları, değişikliklere karşı dirençli olacak şekilde
  tasarlanabilir. Yani, projenizde yapılan değişikliklerin diğer kısımları
  etkileme olasılığını azaltabilir.
  * **Performans**: Design pattern'lar,
  belirli bir problemin çözümü için optimize edilmiş bir yaklaşım sunar. Bu
  nedenle, bu kalıpları kullanmak, performansı artırmanıza yardımcı olabilir.
  *  **Ölçeklenebilirlik**: Design pattern'lar, belirli bir problemin çözümü için
  optimize edilmiş bir yaklaşım sunar. Bu nedenle, bu kalıpları kullanmak,
  performansı artırmanıza yardımcı olabilir.
  * **Esneklik**: Design pattern'lar,
  belirli bir problemin çözümü için optimize edilmiş bir yaklaşım sunar. Bu
  nedenle, bu kalıpları kullanmak, performansı artırmanıza yardımcı olabilir.
</Note>

## Singletons Deseni

Singleton deseni, bir sınıfın yalnızca bir örneğinin olduğundan emin olmayı amaçlayan bir tasarım desenidir. TypeScript dilinde de Singleton deseni kullanılabilir, ancak TypeScript'in doğası gereği, bazı dillerdeki gibi tam anlamıyla private constructor (özel kurucu) kullanmak mümkün değildir. Bununla birlikte, Singleton desenini uygulamak için bazı yöntemler vardır.

İlk olarak, bir sınıfın yalnızca bir örneğini tutmak için bir statik özellik kullanabilirsiniz. Aşağıda, TypeScript ile basit bir Singleton örneği gösterilmektedir:

<CodeGroup title="Singleton">

```ts
class Singleton {
  private static instance: Singleton | null = null

  private constructor() {
    // private constructor
  }

  public static getInstance(): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton()
    }

    return Singleton.instance
  }

  public doSomething(): void {
    console.log("Singleton is doing something")
  }
}

// Kullanım örneği
const singleton1 = Singleton.getInstance()
const singleton2 = Singleton.getInstance()

console.log(singleton1 === singleton2) // true
```

</CodeGroup>

<div>
  Bu örnekte, `getInstance` metodu ile Singleton sınıfının tek bir örneğini alabilirsiniz. Eğer daha önce bir örnek oluşturulmamışsa, `getInstance` metodu yeni bir örnek oluşturur ve bu örneği döndürür. Eğer önce bir örnek oluşturulmuşsa, mevcut örneği döndürür.

Ancak, bu yöntem tam anlamıyla private constructor kullanmaz ve `new Singleton()` ifadesi herhangi bir yerde çağrılabilir. Bu nedenle, sınıfın oluşturulmasını sınırlamak için belirli bir yöntem kullanılması önemlidir.

Bu örnekte, TypeScript'in private constructor özelliği olmadığı için `private constructor()` kullanılarak sınıfın dışından doğrudan bir örneği oluşturulması engellenir. Ancak, dikkatli olunması ve Singleton desenini doğru bir şekilde uygulamak için belirli durumları düşünmek önemlidir.

</div>

## Factory Deseni

Factory deseni (Factory Pattern), bir nesne yaratma sürecini kapsülleme amacı güden bir creational (yaratıcı) tasarım desenidir. Bu desen, nesne oluşturma mantığını ana sınıftan ayırarak, bir alt sınıfın hangi sınıfın nesnesini oluşturacağını belirlemesine izin verir.

Factory deseni, genellikle bir arayüz veya soyut bir sınıf üzerinde duran bir "fabrika" sınıfını içerir. Alt sınıflar bu arayüzü veya soyut sınıfı uygular ve kendi özelleştirilmiş nesnelerini oluşturmak için gerekli yöntemleri sağlarlar.

İşte TypeScript ile basit bir Factory deseni örneği:

<CodeGroup title="Factory">

```ts
// Ürün arayüzü veya soyut sınıf
interface Product {
  operation(): string
}

// ConcreteProduct1
class ConcreteProduct1 implements Product {
  operation(): string {
    return "ConcreteProduct1 operation"
  }
}

// ConcreteProduct2
class ConcreteProduct2 implements Product {
  operation(): string {
    return "ConcreteProduct2 operation"
  }
}

// Fabrika arayüzü veya soyut sınıf
interface Creator {
  factoryMethod(): Product
}

// ConcreteCreator1
class ConcreteCreator1 implements Creator {
  factoryMethod(): Product {
    return new ConcreteProduct1()
  }
}

// ConcreteCreator2
class ConcreteCreator2 implements Creator {
  factoryMethod(): Product {
    return new ConcreteProduct2()
  }
}

// Kullanım
function clientCode(creator: Creator): void {
  const product = creator.factoryMethod()
  console.log(product.operation())
}

// Kullanım örneği
const creator1 = new ConcreteCreator1()
clientCode(creator1)

const creator2 = new ConcreteCreator2()
clientCode(creator2)
```

</CodeGroup>

<div>
  Bu örnekte, `Product` arayüzü veya soyut sınıf, oluşturulacak nesnelerin ortak davranışlarını tanımlar. `ConcreteProduct1` ve `ConcreteProduct2` sınıfları bu arayüzü uygular ve kendi özel davranışlarını sağlarlar.

`Creator` arayüzü veya soyut sınıf, fabrika metodunu tanımlar. Bu metod, alt sınıfların hangi ürünü oluşturacaklarını belirler. `ConcreteCreator1` ve `ConcreteCreator2` sınıfları, bu arayüzü uygular ve kendi factoryMethod implementasyonlarını sağlarlar.

Son olarak, `clientCode` fonksiyonu, bir `Creator` örneği alır ve bu creatörün `factoryMethod`'unu çağırarak belirli bir ürünü oluşturur ve kullanır. Bu şekilde, istemci kodu hangi ürünü kullanacağını bilmeksizin bir nesne yaratabilir.

</div>

## Observer Deseni

Observer deseni, bir nesnenin durumundaki değişiklikleri takip etmek isteyen bir dizi nesnenin (gözlemcilerin) bir nesneye abone olmasını sağlayan bir tasarım desenidir. Bu desen, bir nesnenin durumunda değişiklik olduğunda bağımlı nesneleri otomatik olarak güncellemek için kullanılır. Bu durum, bir nesnenin durumu değiştikçe diğer nesnelerin tepki vermesini sağlar.

Bu desenin ana bileşenleri şunlardır:

- **Subject (Konu)**: Gözlemleyicileri (observers) içeren bir nesne. Durumu değiştikçe gözlemcilerini haberdar eder.

- **Observer (Gözlemci)**: Bir konu üzerinde değişiklikleri takip etmek isteyen arayüze sahip nesneler.

Observer deseni, yaygın olarak kullanıcı arayüzleri, olay sistemleri ve veri alma/gönderme gibi birçok senaryoda kullanılır.

İşte TypeScript ile basit bir Observer deseni örneği:

<CodeGroup title="Observer">

```ts
// Subject (Konu) arayüzü veya soyut sınıf
interface Subject {
  addObserver(observer: Observer): void
  removeObserver(observer: Observer): void
  notifyObservers(): void
}

// ConcreteSubject (Somut Konu)
class ConcreteSubject implements Subject {
  private observers: Observer[] = []
  private state: number = 0

  addObserver(observer: Observer): void {
    this.observers.push(observer)
  }

  removeObserver(observer: Observer): void {
    const index = this.observers.indexOf(observer)
    if (index !== -1) {
      this.observers.splice(index, 1)
    }
  }

  notifyObservers(): void {
    for (const observer of this.observers) {
      observer.update(this.state)
    }
  }

  setState(state: number): void {
    this.state = state
    this.notifyObservers()
  }
}

// Observer (Gözlemci) arayüzü veya soyut sınıf
interface Observer {
  update(state: number): void
}

// ConcreteObserver (Somut Gözlemci)
class ConcreteObserver implements Observer {
  private name: string

  constructor(name: string) {
    this.name = name
  }

  update(state: number): void {
    console.log(`${this.name} notified with state: ${state}`)
  }
}

// Kullanım
const subject = new ConcreteSubject()

const observer1 = new ConcreteObserver("Observer 1")
const observer2 = new ConcreteObserver("Observer 2")

subject.addObserver(observer1)
subject.addObserver(observer2)

subject.setState(1)
subject.setState(2)

// Çıktı:
// Observer 1 notified with state: 1
// Observer 2 notified with state: 1
// Observer 1 notified with state: 2
// Observer 2 notified with state: 2
```

</CodeGroup>

<div>
  Bu örnekte, `ConcreteSubject` bir `Subject` arayüzünü uygular ve
  `ConcreteObserver` bir `Observer` arayüzünü uygular. `ConcreteSubject`,
  içerdiği gözlemcileri (`observers`) takip eder ve durumu değiştiğinde bu
  gözlemcilere haber verir. `ConcreteObserver` ise durumu alır ve kendine özgü
  bir şekilde tepki verir.
</div>

## Decorator Deseni

Decorator deseni, nesne üzerinde dinamik olarak davranış eklemek için kullanılan bir tasarım desenidir. Bu desen, bir nesneyi sarmalayarak (wrap) ve bu sarmalayıcı nesneye ek işlevsellik ekleyerek çalışır. Bu sayede, nesne üzerinde yapılan değişiklikler, nesnenin sarmalayıcıları aracılığıyla etki eder ve bu değişiklikler çalışma zamanında gerçekleştirilebilir.

Decorator deseni, Open/Closed prensibine (bir sınıfın davranışını değiştirmek için sınıfın değiştirilmemesi) uyan ve bir nesnenin davranışını genişletmek veya değiştirmek istediğimizde tercih ettiğimiz bir desenidir.

İşte TypeScript ile basit bir Decorator deseni örneği:

<CodeGroup title="Decorator">

```ts
// Component (Bileşen) arayüzü veya soyut sınıf
interface Coffee {
  cost(): number
  description(): string
}

// ConcreteComponent (Somut Bileşen)
class SimpleCoffee implements Coffee {
  cost(): number {
    return 5
  }

  description(): string {
    return "Simple coffee"
  }
}

// Decorator (Dekoratör) arayüzü veya soyut sınıf
abstract class CoffeeDecorator implements Coffee {
  protected decoratedCoffee: Coffee

  constructor(coffee: Coffee) {
    this.decoratedCoffee = coffee
  }

  cost(): number {
    return this.decoratedCoffee.cost()
  }

  description(): string {
    return this.decoratedCoffee.description()
  }
}

// ConcreteDecorator (Somut Dekoratör)
class MilkDecorator extends CoffeeDecorator {
  constructor(coffee: Coffee) {
    super(coffee)
  }

  cost(): number {
    return this.decoratedCoffee.cost() + 2
  }

  description(): string {
    return this.decoratedCoffee.description() + ", with milk"
  }
}

// ConcreteDecorator (Somut Dekoratör)
class SugarDecorator extends CoffeeDecorator {
  constructor(coffee: Coffee) {
    super(coffee)
  }

  cost(): number {
    return this.decoratedCoffee.cost() + 1
  }

  description(): string {
    return this.decoratedCoffee.description() + ", with sugar"
  }
}

// Kullanım
const simpleCoffee: Coffee = new SimpleCoffee()
console.log(
  `Cost: $${simpleCoffee.cost()}, Description: ${simpleCoffee.description()}`
)

const milkCoffee: Coffee = new MilkDecorator(new SimpleCoffee())
console.log(
  `Cost: $${milkCoffee.cost()}, Description: ${milkCoffee.description()}`
)

const sugarMilkCoffee: Coffee = new SugarDecorator(
  new MilkDecorator(new SimpleCoffee())
)
console.log(
  `Cost: $${sugarMilkCoffee.cost()}, Description: ${sugarMilkCoffee.description()}`
)
```

</CodeGroup>

<div>
  Bu örnekte, `Coffee` arayüzü veya soyut sınıf, dekore edilecek nesnenin temel davranışını belirtir. `SimpleCoffee` sınıfı, bu arayüzü uygular ve temel kahve davranışını sağlar.

`CoffeeDecorator` soyut sınıfı, dekoratörlerin uygulanmasını sağlar ve `ConcreteDecorator` sınıfları, gerçek dekorasyonları uygular. Örneğin, `MilkDecorator` sınıfı süt eklerken, `SugarDecorator` sınıfı şeker ekler.

Sonuç olarak, `SimpleCoffee` nesnesi üzerine `MilkDecorator` ve `SugarDecorator` sarmalayıcıları ekleyerek yeni özellikler ekleyebilir ve nesnenin davranışını değiştirebilirsiniz.

</div>

## Prototype Deseni

Prototype deseni, nesnelerin kopyalarını oluşturmak için kullanılan bir tasarım desenidir. Bu desen, nesne oluşturma sürecini bir prototip nesnesinden türetilen kopyalar üzerinden gerçekleştirir. Bu sayede, bir nesnenin yeni kopyalarını oluşturmak için sınıf hiyerarşilerini yeniden oluşturmak gerekmez.

Prototype deseni, özellikle nesnenin karmaşık bir inşa sürecine sahip olduğu durumlarda kullanışlıdır. Bu desen, nesne oluşturma maliyetini düşürerek ve yeni nesnelerin başka nesnelerle aynı başlangıç durumlarına sahip olmasını sağlayarak performans ve bellek kullanımını iyileştirebilir.

İşte TypeScript ile basit bir Prototype deseni örneği:

<CodeGroup title="Prototype">

```ts
// Prototype (Prototip) arayüzü veya soyut sınıf
interface Cloneable {
  clone(): Cloneable
}

// ConcretePrototype (Somut Prototip)
class ConcretePrototype implements Cloneable {
  private property1: string
  private property2: number

  constructor(property1: string, property2: number) {
    this.property1 = property1
    this.property2 = property2
  }

  clone(): Cloneable {
    // Yeni bir kopya oluşturulur ve mevcut özellikler kopyalanır
    return new ConcretePrototype(this.property1, this.property2)
  }

  // Diğer metotlar ve özellikler...
}

// Kullanım
const prototypeInstance1 = new ConcretePrototype("Value 1", 42)
const clonedInstance1 = prototypeInstance1.clone()

console.log(prototypeInstance1) // Orjinal nesne
console.log(clonedInstance1) // Kopya nesne
```

</CodeGroup>

<div>
  Bu örnekte, `Cloneable` arayüzü veya soyut sınıf, klonlama yeteneğini belirtir. `ConcretePrototype` sınıfı, bu arayüzü uygular ve klonlanabilir nesnenin yapısını ve davranışını tanımlar.

Kullanım örneğinde, `prototypeInstance1` adlı bir orijinal nesne oluşturulur. Ardından, bu nesnenin clone metodunu kullanarak bir kopyası olan `clonedInstance1` oluşturulur. Bu sayede, `clonedInstance1` ve `prototypeInstance1` nesneleri aynı başlangıç durumlarına sahip olur, ancak bağımsız nesnelerdir.

Prototype deseni, özellikle nesnenin içeriği karmaşık ve nesnenin kopyalanması maliyetli olduğu durumlarda kullanılır.

</div>

## Builder Deseni


Builder deseni, bir nesnenin karmaşık yapısını adım adım oluşturan ve nesnenin farklı temsil biçimlerini üretebilen bir tasarım desenidir. Builder deseni, bir nesnenin inşa edilmesi sürecini ayrı bir sınıfa taşıyarak, nesnenin farklı özelliklerini kontrol etmeyi ve bu özelliklere göre nesneyi oluşturmayı sağlar.

İşte TypeScript ile Builder desenini uygulamak için basit bir örnek:

<CodeGroup title="Builder">

  ```ts
  // Üretilen nesne için temsil edilecek arayüz
  class Product {
  private parts: string[] = [];

  addPart(part: string): void {
  this.parts.push(part);
}

  showParts(): void {
  console.log(`Product Parts: ${this.parts.join(', ')}`);
}
}

  // Builder arayüzü
  interface Builder {
  buildPartA(): void;
  buildPartB(): void;
  getResult(): Product;
}

  // ConcreteBuilder sınıfı: Builder arayüzünü uygular
  class ConcreteBuilder implements Builder {
  private product: Product = new Product();

  buildPartA(): void {
  this.product.addPart('PartA');
}

  buildPartB(): void {
  this.product.addPart('PartB');
}

  getResult(): Product {
  return this.product;
}
}

  // Director sınıfı: Builder'ı kullanarak nesne inşa eder
  class Director {
  private builder: Builder;

  constructor(builder: Builder) {
  this.builder = builder;
}

  construct(): void {
  this.builder.buildPartA();
  this.builder.buildPartB();
}
}

  // Kullanım
  const builder: Builder = new ConcreteBuilder();
  const director: Director = new Director(builder);

  director.construct();

  const product: Product = builder.getResult();
  product.showParts();

  ```

</CodeGroup>

<div>
  Bu örnekte, `Product` sınıfı, oluşturulacak nesneyi temsil eder. `Builder` arayüzü, nesnenin inşa edilme sürecini tanımlar. `ConcreteBuilder` sınıfı, `Builder` arayüzünü uygular ve nesnenin farklı parçalarını ekler. `Director` sınıfı, `Builder`'ı kullanarak nesneyi inşa eder.

  Bu sayede, `Director` sınıfı, nesnenin hangi parçalardan oluşacağını belirler, ancak hangi parçaların eklenip çıkarılacağı `ConcreteBuilder` sınıfında belirlenir. Bu, nesne oluşturma sürecini daha esnek hale getirir ve farklı varyasyonlarda nesneler oluşturmak için kullanışlıdır.

</div>

## Facade Deseni



Facade deseni, bir alt sistemdeki nesnelerin karmaşıklığını gizleyen ve bir arayüz sağlayan bir tasarım desenidir. Bu desen, bir alt sistemin iç yapısını müşterilere karşı gizleyerek, alt sistemin kullanımını daha basitleştirir ve daha yüksek seviyeli bir arabirim sunar.

İşte TypeScript ile basit bir Facade deseni örneği:

<CodeGroup title="Facade">

  ```ts
  // Alt sistem sınıfları
  class SubsystemA {
  operationA(): string {
  return 'Subsystem A operation';
}
}

  class SubsystemB {
  operationB(): string {
  return 'Subsystem B operation';
}
}

  class SubsystemC {
  operationC(): string {
  return 'Subsystem C operation';
}
}

  // Facade sınıfı
  class Facade {
  private subsystemA: SubsystemA;
  private subsystemB: SubsystemB;
  private subsystemC: SubsystemC;

  constructor() {
  this.subsystemA = new SubsystemA();
  this.subsystemB = new SubsystemB();
  this.subsystemC = new SubsystemC();
}

  operation(): string {
  let result = 'Facade initiates operations:\n';
  result += this.subsystemA.operationA() + '\n';
  result += this.subsystemB.operationB() + '\n';
  result += this.subsystemC.operationC();
  return result;
}
}

  // Kullanım
  const facade = new Facade();
  const result = facade.operation();
  console.log(result);

  ```

</CodeGroup>

<div>

  Bu örnekte, `SubsystemA`, `SubsystemB`, ve `SubsystemC` alt sistem sınıflarını temsil eder. Bu sınıflar, karmaşık işlemleri gerçekleştirir. `Facade` sınıfı ise bu alt sistemleri yöneten ve müşterilere basitleştirilmiş bir arabirim sunan sınıftır.

  Facade deseni, alt sistemlerin iç yapısındaki karmaşıklığı gizleyerek, müşterinin daha basit bir şekilde kullanımını sağlar. Bu, alt sistemlerdeki değişikliklerin müşteri kodunu etkilememesini sağlar. Facade, alt sistemlerin bir arada çalışmasını koordine edebilir ve müşteriye tek bir noktadan erişim sağlar.

  Bu desen, bir uygulamanın çeşitli bileşenlerini birleştiren ve müşteri kodu için basit bir arayüz sunan durumlarda özellikle faydalıdır.
</div>

## Proxy Deseni



Proxy deseni, bir nesnenin yerine geçen bir kontrol noktasıdır ve bu sayede gerçek nesneyle olan etkileşimi kontrol eder. Bu desen, performans optimizasyonu, erişim kontrolü, giriş doğrulaması veya bir nesnenin yaratılma maliyetinden kaçınma gibi senaryolarda kullanılır.

İşte TypeScript ile basit bir Proxy deseni örneği:

<CodeGroup title="Proxy">

  ```ts
  // Temel öznenin arayüzü
  interface Subject {
  request(): void;
}

  // Gerçek özne sınıfı
  class RealSubject implements Subject {
  request(): void {
  console.log('RealSubject: Handling request.');
}
}

  // Proxy sınıfı
  class Proxy implements Subject {
  private realSubject: RealSubject;

  constructor(realSubject: RealSubject) {
  this.realSubject = realSubject;
}

  private checkAccess(): boolean {
  console.log('Proxy: Checking access.');
  // Burada gerçek bir erişim kontrolü gerçekleştirilebilir.
  return true;
}

  private logAccess(): void {
  console.log('Proxy: Logging access.');
}

  request(): void {
  if (this.checkAccess()) {
  this.realSubject.request();
  this.logAccess();
}
}
}

  // Kullanım
  const realSubject = new RealSubject();
  const proxy = new Proxy(realSubject);

  // Gerçek özneye doğrudan erişim
  realSubject.request();

  // Proxy üzerinden erişim
  proxy.request();


  ```

</CodeGroup>

<div>
  Bu örnekte, `Subject` arayüzü, gerçek öznenin ve proxy'nin uyguladığı arayüzdür. `RealSubject` sınıfı, gerçek işlemleri gerçekleştiren sınıftır. `Proxy` sınıfı ise erişim kontrolü ve loglama gibi ek işlevsellik ekler.

  Proxy deseni, gerçek nesnenin yaratılması veya kullanılması için ek bir kontrol ekler, böylece gerçek nesnenin yaratılma maliyetinden veya gereksiz işlemlerden kaçınılabilir. Aynı zamanda, erişim kontrolü gibi işlevselliği gerçekleştirebilir ve gerçek nesnenin davranışını kontrol edebilir. Bu sayede, istemci kodu değiştirmeden önce veya sonra ek işlevselliği uygulamak daha kolay olabilir.
</div>

## Iterator Deseni


Iterator deseni, bir nesne koleksiyonu üzerinde sırayla gezinmek için bir arayüz sağlayan ve bu koleksiyonun altında bulunan elemanlara erişimi standartlaştıran bir tasarım desenidir. Iterator deseni, koleksiyonun iç yapısını gizler ve istemcilerin koleksiyon üzerinde gezinmeyi basitleştirir.

İşte TypeScript ile basit bir Iterator deseni örneği:

<CodeGroup title="Iterator ">

  ```ts
  // Iterator arayüzü
  interface Iterator<T> {
  next(): T;
  hasNext(): boolean;
}

  // Aggregate arayüzü
  interface Aggregate<T> {
    createIterator(): Iterator<T>;
  }

    // ConcreteAggregate sınıfı
    class ConcreteAggregate<T> implements Aggregate<T> {
      private items: T[] = [];

      addItem(item: T): void {
      this.items.push(item);
    }

      createIterator(): Iterator<T> {
      return new ConcreteIterator<T>(this);
    }

      getItems(): T[] {
      return this.items;
    }
    }

      // ConcreteIterator sınıfı
      class ConcreteIterator<T> implements Iterator<T> {
        private aggregate: ConcreteAggregate<T>;
        private index: number = 0;

        constructor(aggregate: ConcreteAggregate<T>) {
        this.aggregate = aggregate;
      }

        next(): T {
        const currentItem = this.aggregate.getItems()[this.index];
        this.index++;
        return currentItem;
      }

        hasNext(): boolean {
        return this.index < this.aggregate.getItems().length;
      }
      }

        // Kullanım
        const aggregate = new ConcreteAggregate<number>();
          aggregate.addItem(1);
          aggregate.addItem(2);
          aggregate.addItem(3);

          const iterator = aggregate.createIterator();

          while (iterator.hasNext()) {
            const currentItem = iterator.next();
            console.log(`Item: ${currentItem}`);
          }

          ```

</CodeGroup>

<div>
  Bu örnekte, `Iterator` arayüzü, koleksiyon üzerinde gezinme işlemlerini tanımlar. `Aggregate` arayüzü ise bu koleksiyonları oluşturacak sınıflar için bir arayüz sağlar. `ConcreteAggregate` sınıfı, koleksiyonu temsil eder ve `ConcreteIterator` sınıfı, bu koleksiyon üzerinde gezinme işlemlerini uygular.

  Iterator deseni, koleksiyonun iç yapısını gizler ve istemcilerin koleksiyon üzerinde dolaşmasını standartlaştırır. Bu sayede, koleksiyonun iç yapısı değişse bile istemci kodunu değiştirmeye gerek kalmaz. Aynı zamanda, koleksiyon üzerinde farklı gezinme algoritmaları uygulanabilir ve istemci kodu değiştirmeden bu algoritmalar kullanılabilir.
</div>

## Adapter Deseni

Adapter deseni, bir sınıfın arabirimini, başka bir sınıfın beklediği arabirime dönüştüren bir yapısal tasarım desenidir. Bu desen, uyumsuz arabirimlere sahip sınıfların birbirleriyle etkileşimini sağlar.

İşte TypeScript ile basit bir Adapter deseni örneği:

<CodeGroup title="Adapter">

  ```ts
  // Hedef Arabirim
  interface Target {
  request(): string;
}

  // Hedefe Uygun Sınıf
  class ConcreteTarget implements Target {
  request(): string {
  return 'ConcreteTarget: The default behavior.';
}
}

  // Kaynak Sınıf
  class Adaptee {
  specificRequest(): string {
  return 'Adaptee: The specific behavior.';
}
}

  // Adaptör Sınıfı
  class Adapter implements Target {
  private adaptee: Adaptee;

  constructor(adaptee: Adaptee) {
  this.adaptee = adaptee;
}

  request(): string {
  return `Adapter: (Translated) ${this.adaptee.specificRequest()}`;
}
}

  // Kullanım
  const target: Target = new ConcreteTarget();
  console.log(target.request());

  const adaptee: Adaptee = new Adaptee();
  const adapter: Target = new Adapter(adaptee);
  console.log(adapter.request());

  ```

</CodeGroup>

<div>
  Bu örnekte, `Target` arabirimi, istemcinin beklediği standart arabirimi temsil eder. `ConcreteTarget` sınıfı, bu arabirimi uygular. `Adaptee` sınıfı, mevcut ancak istemcinin beklediği arabirime sahip olmayan bir sınıfı temsil eder. `Adapter` sınıfı, `Adaptee` sınıfını kullanarak `Target` arabirimini uygular. Bu sayede, `Adapter` sınıfı, `Adaptee` sınıfının özelliklerini `Target` arabirimine uyacak şekilde dönüştürür.

  Adapter deseni, mevcut sınıfların uyumlu bir şekilde birlikte çalışmasını sağlar ve mevcut kodun yeniden kullanılmasını kolaylaştırır. Adapter, uyumsuz sınıflar arasında bir ara birimi sağlayarak sistemdeki esnekliği artırır.
</div>
